'use strict';

/**
 * Copyright 2022 Phenix Real Time Solutions, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _ = require('phenix-web-lodash-light');
const assert = require('phenix-web-assert');

var aspectRatios = [
    {
        '9x16': [
            {3840: 2160}, // 4k (UHD)
            {1920: 1080}, // 1080p (FHD)
            {1366: 768}, //
            {1280: 720}, // 720p(HD)
            {1024: 576},
            {854: 480}, // 480p
            {640: 360}, // 360p (nHD)
            {320: 180}
        ]
    },
    {
        '3x4': [
            {1600: 1200}, // UXGA
            {1440: 1080},
            {960: 720},
            {800: 600}, // SVGA
            {768: 576},
            {640: 480}, // VGA
            {480: 360},
            {352: 288}, // CIF
            {320: 240}, // QVGA
            {176: 144}, // QCIF
            {160: 120} // QQVGA
        ]
    },
    {
        '16x9': [
            {2160: 3840}, // 4k (UHD)
            {1080: 1920}, // 1080p (FHD)
            {768: 1366}, //
            {720: 1280}, // 720p(HD)
            {576: 1024},
            {480: 854}, // 480p
            {360: 640}, // 360p (nHD)
            {180: 320}
        ]
    },
    {
        '4x3': [
            {1200: 1600}, // UXGA
            {1080: 1440},
            {720: 960},
            {600: 800}, // SVGA
            {576: 768},
            {480: 640}, // VGA
            {360: 480},
            {288: 352}, // CIF
            {240: 320}, // QVGA
            {144: 176}, // QCIF
            {120: 160} // QQVGA
        ]
    }
];
var resolutionSelectionStrategies = {
    fallbackToLower: {
        id: 0,
        name: 'fallbackToLower'
    },
    fallbackToHigher: {
        id: 1,
        name: 'fallbackToHigher'
    },
    fallbackToLowerThenHigher: {
        id: 2,
        name: 'fallbackToLowerThenHigher'
    },
    exact: {
        id: 3,
        name: 'exact'
    }
};

function ResolutionProvider(options) {
    assert.isObject(options, 'options');

    if (options.resolutionSelectionStrategy) {
        assert.isValidType(options.resolutionSelectionStrategy, resolutionSelectionStrategies, 'options.resolutionSelectionStrategy');
    }

    if (options.aspectRatio) {
        assert.isStringNotEmpty(options.aspectRatio, 'options.aspectRatio');
    }

    if (options.resolution) {
        assert.isNumber(options.resolution, 'options.resolution');
    }

    if (options.frameRate) {
        assert.isNumber(options.frameRate, 'options.frameRate');
    }

    this._resolutionSelectionStrategy = options.resolutionSelectionStrategy || resolutionSelectionStrategies.fallbackToLowerThenHigher.name;
    this._defaultAspectRatio = options.aspectRatio || '16x9';
    this._defaultResolution = parseInt(options.resolution, 10) || 720;
    this._defaultResolutionHeight = calculateHeight.call(this, this._defaultAspectRatio, this._defaultResolution);
    this._defaultFrameRate = options.frameRate || 15;
}

ResolutionProvider.prototype.getDefaultResolution = function getDefaultResolution() {
    var longerDimension = this.calculateLongerDimensionByAspectRatio(this._defaultResolution, this._defaultAspectRatio);

    switch (this._defaultAspectRatio) {
    // Portrait
    case '9x16':
    case '3x4':
        return {
            resolution: this._defaultResolution,
            aspectRatio: this._defaultAspectRatio,
            height: longerDimension,
            width: this._defaultResolution
        };
    // Landscape
    case '16x9':
    case '4x3':
    default:
        return {
            resolution: this._defaultResolution,
            aspectRatio: this._defaultAspectRatio,
            height: this._defaultResolution,
            width: longerDimension
        };
    }
};

ResolutionProvider.prototype.getDefaultFrameRate = function getDefaultFrameRate() {
    return this._defaultFrameRate;
};

ResolutionProvider.prototype.getNextResolution = function getNextResolution(height, aspectRatio) {
    assert.isNumber(height, 'height');
    assert.isStringNotEmpty(aspectRatio, 'aspectRatio');

    switch (this._resolutionSelectionStrategy) {
    case resolutionSelectionStrategies.fallbackToLower.name:
        return getNextLowestResolution.call(this, height, aspectRatio);
    case resolutionSelectionStrategies.fallbackToHigher.name:
        return getNextHighestResolution.call(this, height, aspectRatio);
    case resolutionSelectionStrategies.fallbackToLowerThenHigher.name:
        var nextResolution = null;

        if (height > this._defaultResolutionHeight) {
            nextResolution = getNextHighestResolution.call(this, height, aspectRatio);
        } else {
            nextResolution = getNextLowestResolution.call(this, height, aspectRatio);

            if (!nextResolution || !nextResolution.height) {
                nextResolution = getNextHighestResolution.call(this, this._defaultResolution, this._defaultAspectRatio);
            }
        }

        return nextResolution;
    case resolutionSelectionStrategies.exact.name:
    default:
        return;
    }
};

ResolutionProvider.prototype.canResolveNextResolution = function() {
    return this._resolutionSelectionStrategy !== resolutionSelectionStrategies.exact.name;
};

ResolutionProvider.prototype.calculateLongerDimensionByAspectRatio = function calculateLongerDimensionByAspectRatio(shorterDimension, aspectRatio) {
    switch (aspectRatio) {
    case '16x9':
    case '9x16':
        return roundUpToNearestEvenNumber((16 / 9) * shorterDimension);
    case '4x3':
    case '3x4':
        return roundUpToNearestEvenNumber((4 / 3) * shorterDimension);
    default:
        throw new Error('Aspect Ratio not supported');
    }
};

function roundUpToNearestEvenNumber(value) {
    assert.isNumber(value, 'value');

    return 2 * Math.floor((value + 1) / 2);
}

function calculateHeight(aspectRatio, resolution) {
    assert.isStringNotEmpty(aspectRatio, 'aspectRatio');
    assert.isNumber(resolution, 'resolution');

    switch (aspectRatio) {
    case '16x9':
    case '4x3':
        return resolution;
    case '9x16':
        return roundUpToNearestEvenNumber((16 / 9) * resolution);
    case '3x4':
        return roundUpToNearestEvenNumber((4 / 3) * resolution);
    default:
        throw new Error('Aspect Ratio not supported');
    }
}

function getNextHighestResolution(height, aspectRatio) {
    var aspectRatioHeights = getObjectValueInArray(aspectRatio, aspectRatios);
    var aspectRatioIndex = getIndexInArray(aspectRatio, aspectRatios);
    var heightIndex = getIndexInArray(height.toString(), aspectRatioHeights);
    var isLargestHeight = heightIndex === 0;
    var isSmallestAspectRatio = aspectRatios.length - 1 === aspectRatioIndex;

    var newAspectRatio;
    var newAspectRatioHeights;
    var newHeight;
    var newWidth;

    if (heightIndex < 0) {
        heightIndex = getNextHighestKeyIndex(height, aspectRatioHeights);

        if (heightIndex < 0) {
            return null;
        }
    } else {
        if (isLargestHeight) {
            if (isSmallestAspectRatio) {
                return null;
            }

            aspectRatioIndex++;

            newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);
            newAspectRatioHeights = getObjectValueInArray(newAspectRatio, aspectRatios);
            heightIndex = getNextHighestKeyIndex(this._defaultResolutionHeight, newAspectRatioHeights);

            if (heightIndex < 0) {
                return null;
            }

            newHeight = getIndexKey(heightIndex, aspectRatioHeights);
            newWidth = this.calculateLongerDimensionByAspectRatio(newHeight, newAspectRatio);

            return {
                resolution: Math.min(newHeight, newWidth),
                aspectRatio: newAspectRatio,
                height: parseInt(newHeight, 10),
                width: parseInt(newWidth, 10)
            };
        }

        heightIndex--;
    }

    newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);
    newAspectRatioHeights = getIndexValue(aspectRatioIndex, aspectRatios);
    newHeight = getIndexKey(heightIndex, newAspectRatioHeights);
    newWidth = newAspectRatioHeights[heightIndex][newHeight];

    return {
        resolution: Math.min(newHeight, newWidth),
        aspectRatio: newAspectRatio,
        height: parseInt(newHeight, 10),
        width: newWidth
    };
}

function getNextLowestResolution(height, aspectRatio) {
    var aspectRatioHeights = getObjectValueInArray(aspectRatio, aspectRatios);
    var aspectRatioIndex = getIndexInArray(aspectRatio, aspectRatios);
    var heightIndex = getIndexInArray(height.toString(), aspectRatioHeights);
    var isSmallestHeight = heightIndex === aspectRatioHeights.length - 1;
    var isSmallestAspectRatio = aspectRatios.length - 1 === aspectRatioIndex;

    var newAspectRatio;
    var newAspectRatioHeights;
    var newHeight;
    var newWidth;

    if (!_.isNumber(heightIndex)) {
        heightIndex = getNextLowestKeyIndex(height, aspectRatioHeights);

        if (!heightIndex) {
            return;
        }
    } else {
        if (isSmallestHeight) {
            if (isSmallestAspectRatio) {
                return null;
            }

            aspectRatioIndex++;

            newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);
            newHeight = this._defaultResolutionHeight;
            newWidth = this.calculateLongerDimensionByAspectRatio(newHeight, newAspectRatio);

            return {
                resolution: Math.min(newHeight, newWidth),
                aspectRatio: newAspectRatio,
                height: parseInt(newHeight, 10),
                width: parseInt(newWidth, 10)
            };
        }

        heightIndex++;
    }

    newAspectRatio = getIndexKey(aspectRatioIndex, aspectRatios);
    newAspectRatioHeights = getIndexValue(aspectRatioIndex, aspectRatios);
    newHeight = getIndexKey(heightIndex, newAspectRatioHeights);
    newWidth = newAspectRatioHeights[heightIndex][newHeight];

    return {
        resolution: Math.min(newHeight, newWidth),
        aspectRatio: newAspectRatio,
        height: parseInt(newHeight, 10),
        width: parseInt(newWidth, 10)
    };
}

function getObjectValueInArray(value, collection) {
    var valueObject = _.find(collection, function(item) {
        return Object.prototype.hasOwnProperty.call(item, value);
    });

    return valueObject ? valueObject[value] : null;
}

function getIndexInArray(value, collection) {
    return _.findIndex(collection, function(item) {
        return Object.prototype.hasOwnProperty.call(item, value);
    });
}

function getIndexKey(index, collection) {
    var keys = _.keys(collection[index]);

    return keys[0];
}

function getIndexValue(index, collection) {
    var keys = _.keys(collection[index]);

    return collection[index][keys[0]];
}

function getNextHighestKeyIndex(value, collection) {
    if ( _.keys(collection[0])[0] < value) {
        return -1;
    }

    return _.reduce(collection, function(closestIndex, nextItem, index) {
        if (!closestIndex) {
            return index;
        }

        var currentClosestKey = _.keys(collection[closestIndex])[0];
        var nextKey = _.keys(nextItem)[0];

        if (nextKey < value) {
            return closestIndex;
        }

        return Math.abs(value - nextKey) < Math.abs(value - currentClosestKey) ? index : closestIndex;
    });
}

function getNextLowestKeyIndex(value, collection) {
    if ( _.keys(collection[collection.length - 1])[0] > value) {
        return null;
    }

    return _.reduce(collection, function(closestIndex, nextItem, index) {
        if (!closestIndex) {
            return index;
        }

        var currentClosestKey = _.keys(collection[closestIndex])[0];
        var nextKey = _.keys(nextItem)[0];

        if (nextKey > value) {
            return closestIndex;
        }

        return Math.abs(value - nextKey) < Math.abs(value - currentClosestKey) ? index : closestIndex;
    });
}

module.exports = ResolutionProvider;